{
  "name": "ReceiptCreator",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "serialized_note",
          "type": {
            "kind": "array",
            "length": 0,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "H4sIAAAAAAAA/+1VQQ4CIQws7C5sheg/PGHiA/b/rxK0TSYsnuwejDZpgBaGYWggEpGjl03VZ9qb5jdpy2d2c3ZY5Uie/kt4ToY83YCng7po7VI9VI/VrxJn2tcOy1zEYlnbzEMsSn+Sts1ZjXUKwM0IswT7+ywM2sygkWqzDDQPA83jQPMVMC6Qp+5OzrKGbc92x7tWc914gz7D+Y6oh5Mt5rMekjFmw8igieqn3BPkE+iVjfVysKfi6hj5/bn+NleGGL5Bml8h5rtz4DuXAaN/I0w/T5INPGze7N2np/YAao7Tjj0JAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "token",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+2dB3RcxRWG7660Kja2gYTYBgO2KbbB4LdF0i5FYCwMmBJTTQftatcYy3IVvXdSSSeQQkjvpJNOSO+k94SQ3kPvhvmP78DsesV5e3Rnz865eufcc+XV9Wi+KW/+9/a9O1MTRNOM2cP+eDD7aHxHOmXKSNUpNxv15nLlvkw5nU0PRplCMd8T5XqKvfl0Pt2T7xnK5LPZcj6X7ysUC31RIZ3LltOVnkK2wgWn5OoY+eDuMGV0eODuaHHuTlNGpwfuTmHuscb7eOs5Q7CeCW7L2VzedGObjc1Q6hcam8l9hnbZlttlZgvUa0enXrMn+uu5dtmpTn/t1AL1mmWsjZ6f/wnnZ3I+w3Ew+2h8R3o6yZ4b7LGzsWn8c7exZA1HB7NKsnQ45UuWKdzmkdseSaeNbHtYn+LPyfHu/5nK7dguzJxw6mDLtf+2f6vL2BT+ed1gafXiDStH15RHNm10B4ENdgd0suazbgZ1490Gsr9zF/CqmkkQu2UmhcueRXIr+c5y9YraqLqXqaZjpPiT5EclSY2Bvt5SoZApF322wSySP8vC2xm4i7FdacsqP8fYXGO7Gdvd2B7G9jQ2z9h8YwuM7WVsB/6/7pmHnM9qJ687Ue0c8XDGjXyfcdvqcLfX4U45frLze6ppA3sW7pSt85Db3lTTF7VtTs7ft1d5gnVJ42w/k8sqj6wfLY+Wl48Wh1eVlo6OlDatWjuyZHB42B2YtuJ2gLbVabjaz91O6OKfU85n3Q6g/cyW1eV85nawbRhvK0cbba1tiOTPILOptc+ifGTcttibPbRtymkXG4MOf6ZOm7m6N8kxyReISYxRzliz1dtgsHAAf7qmMlJ/YyE3qPRNgoXkZ4BJi/zZAszlypZj7wDaT1qOSjLv45SVzmczmb4s4vJDUTo3VMrkM5mhYi4qRYOlTLmQSxcquUwuWxoqFU2Zg+lKVBksFSr5LfVyL3zdQ3r+7CNXVtUF7770/ApWb4XzIGuqLlvqtZ/Xk52vztnXQ7mLSG7Q++JeJN9HdesqcaJb5KHciGQnJiZhxL5ZKm0O+VkEhMdFlUqzZ5EMKVNpAPel0jLcoNKTJEN+Bpi0SpsjwGxVWjqA9pNWaZLMWQpPpWVJdjGwR44mVJpI5+Q8lNtDra3SwN0j30deVFqG6ypdbi/JTkxMwl5qrkqbS34WAeFxUaXS+tjnSZlKA7gvlZbnBpWeJHnyM8CkVdpcAWar0voCaD9plSbJXKDwVFqBZBcDe+xHEypNpHP281Du/tTaKg3c+8v3kReVlue6Spd7AMlOTEzCA6i5Km0e+VkEhMdFlUo7kH0/KVNpAPel0vq5QaUnST/5GWDSKm2eALNVaQcG0H7SKk2S+SAKT6UdRLKLATn1m1Bp4yzTdo50uYuptVUauBfL95EXldbPdZUu9xCSnZiYhIdQc1XafPKzCAiPiyqVtoT9AClTaQD3pdIGuEGlJ8kA+Rlg0iptvgCzVWlLAmg/aZUmyXwohafSDiXZxcAeS2lCpYl0zlIP5R5Gra3SwH2YfB95UWkDXFfpcg8n2YmJSXg4NVelLSA/i4DwuKhSaUewX0bKVBrAfam0Zdyg0pNkGfkZYNIqbYEAs1VpRwTQftIqTZL5SApPpR1JsouBPY6iCZUm0jlHeSj3aGptlQbuo+X7yItKW8Z1lS73GJKdmJiEx9DW6kz6hJoUbINdyM8iIt1XuwrUs95b+9J9I5m5Ya8m9U00viPdH0g9BwKpZ7OE3XjHZ1KQeTeFzLtTGOfel5LcuRd1Q3IFK1xRts1lBZ9hn2c/ydhyZrI5+Wy/bnb8Huz3pBfOmbWdsWOd8qxYHiseV/THNRh/fIPxJzQYf2KD8Sc1GL+iwfiTG4w/pcH4UxuMP63B+NMbjD+jwfgzG4w/q8H4sxuMH3Tik2PEIzlKMWZcKWbcUMy4csy4Ssy4lTHjzokZtypm3Lkx41bHjBuOGbcmZtxIzLi1MePWxYxb78St4Lhj+fezKF7uw+PYH8/+BPYnsj+J/Qr2J7M/hf2p7E9jfzr7M9ifyf4s9mezH2RfZF9iP8S+zL7CfiX7c9ivYn8u+9Xsh9mvYT/Cfi37dezXx2yfCd8cj9QoG2jr86/VJcvZb2C/vbGNVH1IX4MmSE77baLm6PJofIfoPZHRQJjbBJnPC4S5XZD5/ECYU4LMFwTC3CHIfGEgzJ2CzBcFwryjIPPFgTDPEGS+RCHzpQqZL1PIfLlC5isUMl+pkPkqhcxXK2S+RiHztQqZr1PIfL1C5hsUMt+okPllCplfrpD5FQqZX6mQ+VUKmV+tkPkmhcyvUcj8WoXMr1PI/HqFzG9QyPxGhcxvUsh8s0LmNytkvkUh860Kmd+ikPmtCpnfppD57QqZb1PI/A6FzLcrZH6nQuZ3KWR+t0Lm9yhkfq9C5vcpZH6/QuYPKGT+oELmDylk/rBC5o8oZP6oQuY7FDJ/TCHzxxUyf0Ih8ycVMn9KIfOnFTJ/RiHznQqZP6uQ+XMKmT+vkPkLCpm/qJD5SwqZv6yQ+S6FzF9RyHy3QuavKmT+mkLmrytk/oZC5m8qZP6WQuZvK2T+jkLm7ypk/p5C5u8rZP6BQuYfKmS+RyHzjxQy/1gh808UMv9UIfPPFDL/XCHzLxQy/1Ih868UMv9aIfNvFDL/ViHz7xQy/14h8x8UMt+rkPmPCpnvU8j8J4XMf1bI/BeFzH9VyPw3hcx/V8j8D4XM/1TI/C+FzP9WyPwfhcz/Vcj8P4XM/1fIfL9C5gcUMj8YCPNGQeaHFPbzwwqZH1HI/KhC5scUMj+ukPkJhcxPKmR+SiHz0wqZNytkfiYQ5i5BZkqEwdwtyJwIhHmSIHMyEObJgsxtgTBvI8jcHgjzFEHmVCDMUwWZOwJhnibI3BkI87aCzF2BMG8nyNwdCPP2gsyTAmF+kSDz5ECYXyzIvE0gzDsIMk8JhPklgsxTBZmnczkJZm4z1m4sZazDWKcxXBPiGgnXDNDQ0JTQWNAcWIOxJuEcjXMW5jDGNPoYzNOdNr2V/SZjo8bOM3a+sQuMXWjsImMXG7vE2KXGLjN2ubErjF1p7CpjVxu7xti1xq4zdr2xG4zdaAz73GPfd+yDjn3BsU829o2+yRj2FcY+u9h3FvuwYl9S7NOJfStvNoZ9DW/hOmIfOOyLhn3CsG/Wbcawr9LtxrDvDvahwb4s2KcE+3ZgHwvs64B9DpD3H3nwkRceedKRN/wOY8grjTzLyDuMPLzIS4s8rchbeqcx5LVEnkfkPUQeQOTFQ5445E27yxjyat1tDHmXkIcIeXmQpwZ5W5DHBHk9kOcCeR+QBwF5AfCePN4bv8cY3ivGe7Z47xTvYeK9RLynh/fW8B4X3mvCez547wXvgeC9CLwngOfm7zWG56rvM4bnbvEcKp7LxHOKeG4Pz7HhuS4854TnfvAcDJ4LwXMSeG4A36Pje2V8z4rvHfE9HL6Xwvc0+N4C9/FxXxv3eXHfE/cBcV8M94lw3wSDE9fVuM7EdReuQ6DLoVOh26BjsK5jncN5H+dBnBcwT+zxLGHFVHtU8QAA",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "transfer_with_receipt_note",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "token_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "from",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "to",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "amount",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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"
    ],
    "fileMap": {
      "1": {
        "source": "mod receipt_note;\n\ncontract ReceiptCreator {\n  use dep::std;\n\n  use dep::aztec::{\n    context::{PrivateContext, PublicContext, Context},\n    note::{\n      note_header::NoteHeader,\n      utils as note_utils,\n    },\n    state_vars::{\n      map::Map,\n      immutable_singleton::ImmutableSingleton,\n    },\n    types::address::{AztecAddress},\n    selector::compute_selector,\n  };\n\n  use dep::authwit::{\n      auth::{\n          assert_current_call_valid_authwit,\n          assert_current_call_valid_authwit_public,\n      },\n  };\n\n  use crate::receipt_note::{ReceiptNote, ReceiptNoteMethods, RECEIPT_NOTE_LEN};\n\n  struct Storage {\n     receipt: Map<ImmutableSingleton<ReceiptNote, RECEIPT_NOTE_LEN>>\n   } \n\n  \nimpl Storage {\n    \n  fn init(context: Context) -> Self {\n      \n    Storage {\n          \n      receipt: Map::new(\n            \n        context,\n            \n        1,\n            |context, slot| {\n              ImmutableSingleton::new(context, slot, ReceiptNoteMethods)\n            }\n          )\n      } \n    }\n  }\n\n  #[aztec(private)]\n  fn constructor(token: AztecAddress) {\n        let selector = compute_selector(\"_initialize((Field))\");\n        context.call_public_function(context.this_address(), selector, [token.address]);\n  }\n\n  #[aztec(private)]\n  fn transfer_with_receipt_note(token_address: Field, from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n\n    let selector = compute_selector(\"transfer(AztecAddress,AztecAddress,Field,Field)\");\n\n    context.call_private_function(\n      token_address,\n      selector,\n      [from.address, to.address, amount, nonce]\n    )\n\n\n  }\n\n // fn transfer_with_receipt_note(token_address: Field, from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n //}\n\nunconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, serialized_note: [Field; 0]) -> [Field; 4] {\n        [0, 0, 0, 0]\n    }\n\n}\n",
        "path": "/Users/arj/work/workingdoge/code/payment_reciept/contracts/src/main.nr"
      },
      "37": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    BLOCK_HEADER_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__BLOCK_HASH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:block-header\nstruct BlockHeader {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:block-header\n\nimpl BlockHeader {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; BLOCK_HEADER_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn deserialize(deserialized: [Field; BLOCK_HEADER_LENGTH]) -> Self {\n        BlockHeader {\n            note_hash_tree_root: deserialized[0],\n            nullifier_tree_root: deserialized[1],\n            contract_tree_root: deserialized[2],\n            l1_to_l2_messages_tree_root: deserialized[3],\n            blocks_tree_root: deserialized[4],\n            public_data_tree_root: deserialized[5],\n            global_variables_hash: deserialized[6],\n        }\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n\n    pub fn block_hash(self) -> Field {\n        // TODO(#3442): Unify the ordering in `BlockHeader::serialize` function and the ordering\n        // in the block hash preimage --> This requires changes in the circuits.\n        let inputs = [\n            self.global_variables_hash,\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.public_data_tree_root\n        ];\n        pedersen_hash(inputs, GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_header.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/aztec/abi.nr"
      },
      "40": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    BlockHeader,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n    get_block_header::get_block_header,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_header: BlockHeader,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_header: inputs.block_header,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_block_header(self, block_number: Field) -> BlockHeader {\n        get_block_header(block_number, self)\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.block_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, self.this_address(), self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_header: BlockHeader {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    blocks_tree_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_header: BlockHeader::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_header: inputs.block_header,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.inputs.block_header,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, this, self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}\n",
        "path": "/aztec/context.nr"
      },
      "41": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse crate::constants_gen::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    // TODO(#1205) This is probably not the right index to use\n    pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    pedersen_hash_with_separator(inputs, hash_index)\n}\n",
        "path": "/aztec/hash.nr"
      },
      "56": {
        "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n",
        "path": "/aztec/oracle/arguments.nr"
      },
      "57": {
        "source": "use crate::constants_gen::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(_contract_address: Field, _function_selector: Field, _args_hash: Field) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained pub fn call_private_function_internal(contract_address: Field, function_selector: Field, args_hash: Field) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(contract_address, function_selector, args_hash)\n}\n",
        "path": "/aztec/oracle/call_private_function.nr"
      },
      "67": {
        "source": "\n// contract_address + \n// args_hash +\n// crate::abi::FUNCTION_DATA_SIZE +\n// crate::abi::CALL_CONTEXT_SIZE +\n// = 2 + 4 + 7\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE: Field = 13;\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(_contract_address: Field, _function_selector: Field, _args_hash: Field) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(contract_address: Field, function_selector: Field, args_hash: Field) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {\n    enqueue_public_function_call_oracle(contract_address, function_selector, args_hash)\n}\n",
        "path": "/aztec/oracle/enqueue_public_function_call.nr"
      },
      "73": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::hash::pedersen_hash;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    pub fn hash(self) -> Field {\n        pedersen_hash([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n",
        "path": "/aztec/private_call_stack_item.nr"
      },
      "74": {
        "source": "use crate::{\n    abi,\n    hash::pedersen_hash,\n    abi::{\n        PublicCircuitPublicInputs,\n        FunctionData,\n    },\n};\nuse crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__CALL_STACK_ITEM,\n};\n\n// oracles\nuse crate::oracle::{\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n};\n\nstruct PublicCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PublicCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PublicCallStackItem {\n    pub fn hash(self) -> Field {\n        pedersen_hash([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\n",
        "path": "/aztec/public_call_stack_item.nr"
      }
    }
  }
}